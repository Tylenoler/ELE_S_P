好，这里我给你一份**“从工程师视角”的完整 Modbus RTU 介绍**。  
不是百科式堆概念，而是**为什么这样设计、怎么用、不容易踩坑**的版本，适合你现在这个阶段。

---

# 一、Modbus RTU 是什么？（一句话）

> **Modbus RTU 是一种基于串口（RS485/RS232）的主从式工业通信协议，特点是：简单、稳定、历史悠久。**

- **Modbus**：协议内容（帧格式、功能码、寄存器模型）
    
- **RTU**：二进制传输方式（区别于 ASCII）
    

---

# 二、Modbus RTU 的核心设计思想（非常重要）

Modbus RTU 的设计目标从来不是“优雅”，而是：

> **在极其有限的硬件条件下，可靠地把数据传过去**

因此它的特点是：

|特点|说明|
|---|---|
|主从模型|一个主站，多个从站|
|半双工|RS485 总线|
|无连接|不握手，不建连接|
|无长度字段|靠时间间隔判帧|
|CRC 校验|保证数据完整性|
|极度简单|8 位 MCU 也能跑|

---

# 三、物理层 & 链路层

## 1️⃣ 常用物理层

- **RS485（最常见）**
    
    - 半双工
        
    - 多机挂总线
        
- RS232（点对点，少见）
    

### RS485 特点

- A/B 差分
    
- 抗干扰强
    
- 适合工业现场
    

---

## 2️⃣ 通信参数（必须一致）

|参数|常见值|
|---|---|
|波特率|9600 / 19200 / 115200|
|数据位|8|
|校验位|None / Even / Odd|
|停止位|1|

📌 **这些不是 Modbus 自动协商的，必须人工配置一致**

---

# 四、Modbus RTU 的帧结构（重点）

### 基本帧格式

```
| 地址 | 功能码 | 数据 | CRC_L | CRC_H |
```

|字段|长度|说明|
|---|---|---|
|地址|1 字节|从站地址（1~247）|
|功能码|1 字节|操作类型|
|数据|N 字节|参数 / 返回值|
|CRC|2 字节|CRC16-Modbus（低字节先发）|

---

## ⚠️ 帧结束的关键：不是特殊字节，而是“时间”

### Modbus RTU 判帧规则

> **总线空闲 ≥ 3.5 个字符时间 = 一帧结束**

这也是为什么：

- **DMA + 空闲中断** 非常适合 Modbus RTU
    
- 不适合纯轮询阻塞接收
    

---

# 五、地址机制（主从模型）

- 地址范围：
    
    - `1 ~ 247`：有效从站
        
    - `0`：广播地址（从站不回应）
        

### 广播特点

- 主站发
    
- 所有从站执行
    
- **无返回帧**
    

---

# 六、功能码（Functional Code）

这是 Modbus 的“灵魂”。

## 常用功能码一览

|功能码|名称|说明|
|---|---|---|
|01|Read Coils|读线圈|
|02|Read Discrete Inputs|读离散输入|
|03|Read Holding Registers|**最常用**|
|04|Read Input Registers|读输入寄存器|
|05|Write Single Coil|写单线圈|
|06|Write Single Register|写单寄存器|
|10 (0x10)|Write Multiple Registers|写多寄存器|

📌 **03 / 06 / 10 是工业现场的绝对主力**

---

# 七、寄存器模型（非常容易误解）

Modbus 定义了 **4 种逻辑区**：

|区域|位宽|访问|常见叫法|
|---|---|---|---|
|Coil|1 bit|R/W|线圈|
|Discrete Input|1 bit|R|输入|
|Holding Register|16 bit|R/W|保持寄存器|
|Input Register|16 bit|R|输入寄存器|

⚠️ **注意：**

- 这是“逻辑模型”
    
- 和 MCU 内存 **没有任何必然关系**
    

---

## 关于“40001 / 30001”的坑

> **40001 不是地址，是文档标记方式**

真正帧里用的是：

```
寄存器地址 = 文档地址 - 1
```

这是 Modbus 最大的历史遗留坑之一。

---

# 八、CRC16-Modbus

## CRC 参数（固定）

- 多项式：`0xA001`
    
- 初始值：`0xFFFF`
    
- 位序：LSB-first
    
- 结果发送：**低字节 → 高字节**
    

### 示例

```
01 03 00 00 00 02 → CRC = 0xC40B
发送：0B C4
```

在 **Modbus RTU** 中，**CRC16 校验值的发送顺序是：先低字节（Low Byte），再高字节（High Byte）**。

---

## 一句话结论 ✅

> **CRC = 16 位 → 先发 CRC_L，再发 CRC_H（小端序）**

---

## 具体说明

Modbus RTU 使用的是 **CRC-16 (Modbus)** 算法，参数是：

- 多项式：`0xA001`
    
- 初始值：`0xFFFF`
    
- 结果：16 位（2 字节）
    

### 发送顺序（非常关键）

```
数据帧 + CRC低字节 + CRC高字节
```

⚠️ **不是高字节在前！**  
很多初学者这里会搞反，导致从机直接丢帧。

---

## 举个标准例子 📌

### 主站发送（读保持寄存器）

```
01 03 00 00 00 02
```

计算 CRC16(Modbus) 得到：

```
CRC = 0xC40B
```

### 实际发送顺序：

```
01 03 00 00 00 02 0B C4
                 ↑  ↑
              CRC_L CRC_H
```

---

## 用 C 代码演示发送方式（STM32 常见写法）

```c
uint16_t crc = Modbus_CRC16(buf, len);

tx_buf[len++] = crc & 0xFF;        // 低字节
tx_buf[len++] = (crc >> 8) & 0xFF; // 高字节
```

---

## 和你现在项目的关系（结合你的 RS485 + STM32）

你现在用的是：

- **STM32H743**
    
- **USART + RS485**
    
- 上位机通信
    

如果你遇到：

- 上位机显示 **CRC 错误**
    
- 示波器/逻辑分析仪看着数据对，但就是不回
    

👉 **90% 的可能是 CRC 字节顺序发反了**

---

## 快速自检清单 ✅

-  CRC 算法用的是 Modbus（不是 CCITT）
    
-  初值是 `0xFFFF`
    
-  多项式是 `0xA001`
    
-  **发送顺序：低字节 → 高字节**
    


我分层给你讲清楚 **“为什么 Modbus RTU 要小端发 CRC，而很多软件却显示成大端”**。

---

## 一、先给结论（核心原因）✅

> **Modbus RTU 并不是“要求整体小端序”，而是：**
> 
> 🔹 **CRC 在算法内部是按“低位优先”的移位逻辑计算的**  
> 🔹 **协议规范明确规定：CRC 结果“低字节先传，高字节后传”**
> 
> 而你看到的 **“大端序 CRC”只是“人类显示习惯”，不是发送顺序**。

---

## 二、关键误区：你看到的“大小端”到底指的是什么？

我们先把三件事严格区分开：

|层级|是什么|是否等于发送顺序|
|---|---|---|
|**CRC 算法数学结果**|一个 16 位数|❌|
|**软件显示方式**|`0xC40B` 还是 `C4 0B`|❌|
|**Modbus RTU 线上发送顺序**|`0B C4`|✅|

👉 **Modbus 只关心最后一行**

---

## 三、为什么 CRC 计算“天生偏向小端”？（本质原因）

### 1️⃣ Modbus CRC 是 **LSB-first（低位优先）算法**

Modbus CRC16 的核心特征：

- 每一位计算时：
    
    - **先处理最低位（bit0）**
        
    - 右移
        
- 使用多项式：`0xA001`（这是 `0x8005` 的 bit-reverse）
    

这和 **Intel x86 的小端思维是完全一致的**

> **先算低位 → 低位更“自然”成为第一个字节**

---

### 2️⃣ CRC 的“低字节”本质上是 **最先稳定的结果**

CRC 计算流程是：

```
字节1 → 位0..7
字节2 → 位0..7
...
```

最终得到 16 位寄存器：

```
[ 高8位 ][ 低8位 ]
```

但因为 **低位参与移位和异或的次数更多、更早**  
👉 **规范干脆规定：低字节先发**

这不是偶然，是工程上的一致性选择。

---

## 四、那为什么很多软件显示成“大端序”？🤔

### 这是“人类阅读习惯”，不是协议需求

举个你一定见过的情况：

### 软件显示：

```
CRC: C40B
```

这是：

```
高字节 = C4
低字节 = 0B
```

但**软件只是告诉你 CRC 的数值是多少**，并没有告诉你**怎么发**。

### 实际 Modbus RTU 帧必须是：

```
... 0B C4
```

---

## 五、一个非常形象的类比 🧠

把 CRC 当成一个 **uint16_t**

```c
uint16_t crc = 0xC40B;
```

### 不同视角：

|视角|看到的|
|---|---|
|程序员打印|`0xC40B`|
|内存（小端 MCU）|`0B C4`|
|Modbus RTU 线缆|`0B C4`|

👉 **Modbus 选择了“按内存顺序直接发”**

---

## 六、为什么 Modbus 不“统一大端”，反而反直觉？

历史原因 + 工业现实：

### 1️⃣ Modbus 出生很早（1979）

- 运行在：
    
    - 8 位 MCU
        
    - 小端 CPU
        
- 内存直接发送最省资源
    

### 2️⃣ 工业现场优先考虑：

- **实现简单**
    
- **代码短**
    
- **CPU 占用低**
    

👉 不是“优雅”，是“活着最重要”

---

## 七、你现在看到“软件算出来是大端”的正确理解方式 ✅

以后你可以这样判断：

> 🔹 **看到 CRC = 0xABCD**
> 
> ❓问自己一句：  
> 👉 **这是“值”，还是“线上顺序”？**

如果是 Modbus RTU：

```
发送顺序永远是：CD AB
```

---

## 八、结合你现在 STM32 + RS485 的实战建议 🔧

### 永远用这一行，不要想太多：

```c
tx[len++] = crc & 0xFF;        // 低字节
tx[len++] = crc >> 8;          // 高字节
```

### 不要做的事 ❌

- 不要因为上位机显示 `C4 0B` 就改顺序
    
- 不要 memcpy 一个 uint16_t 直接丢进去（跨平台有坑）
    

---

## 九、一句话总结（你可以记这个）

> **Modbus RTU 的 CRC 不是“小端显示”，而是“低字节先传”**  
> **软件显示的是“数值”，协议规定的是“顺序”**

如果你愿意，下一步我可以：

- 给你 **画一个 CRC 移位过程的位级示意**
    
- 或 **用你之前那帧 `01 03 ...` 实时手算 CRC，带你走一轮**
    



---

## 一、先给结论（可以直接照着用）✅

> **公司内部自定义协议：**
> 
> 🔹 **推荐：CRC 按“大端序（高字节先发）”**  
> 🔹 **前提：在协议文档里写清楚**
> 
> ❗**只有在“强兼容 Modbus / 低端 MCU 极简实现”时，才选小端序**

---

## 二、为什么“内部协议”更适合大端序？

### 1️⃣ 工程一致性（最重要）

现实情况：

- 长度字段：大端
    
- 命令字：大端
    
- 地址：大端
    
- 寄存器：大端
    

如果 CRC 突然来个：

```
CRC_L CRC_H
```

👉 **认知负担立刻上升**

📌 **协议一致性 > CPU 便利性**

---

### 2️⃣ 调试 & 人眼友好 👀

你一定经历过：

```
软件显示：CRC = 0xC40B
抓包看到：0B C4   ← 反着
```

如果是内部协议，用大端：

```
抓包看到：C4 0B
```

✔ **一眼就能对上**  
✔ 新人不容易犯错  
✔ 少解释 10 次“低字节先发”

---

### 3️⃣ 跨平台更稳（MCU / Linux / 上位机）

大端序天然适合：

- 网络协议（TCP/IP）
    
- PC 软件
    
- Python / Java
    
- Wireshark / 各类抓包工具
    

👉 **“网络字节序 = 大端”是事实标准**

---

## 三、那小端序什么时候更合适？（别一刀切）

### ✅ 适合小端 CRC 的场景

|场景|原因|
|---|---|
|完全 Modbus RTU 兼容|规范要求|
|8 位 MCU + 裸机|`uint16_t` 直接拆|
|极端省代码|少 1~2 行|
|历史包袱|已有设备|

📌 **这是“历史/兼容选择”，不是“设计最优”**

---

## 四、真正重要的不是大小端，而是这 3 条规则 ❗

如果你在公司内部设计协议，**这三条比“大小端”重要 10 倍**：

---

### ✅ 规则 1：CRC 只是一段“字段”，不是 CPU 类型

**正确写法（协议文档）**：

> CRC16 字段：
> 
> - 多项式：0x1021 / 0xA001
>     
> - 初始值：0xFFFF
>     
> - **发送顺序：高字节在前**
>     

❌ 错误写法：

> CRC 使用小端 / 大端

（这是实现细节，不是协议）

---

### ✅ 规则 2：明确“线上字节顺序”，不要提内存

协议文档一定要写：

```
Frame:
| Header | Len | Cmd | Data | CRC_H | CRC_L |
```

而不是：

```
CRC(uint16_t)
```

---

### ✅ 规则 3：CRC 计算和 CRC 发送顺序是两回事

很多 Bug 来自这句话没想清楚：

> **CRC 算法 ≠ CRC 发送顺序**

你完全可以：

- CRC 算法：Modbus CRC16
    
- 发送顺序：大端
    

✔ 没任何问题

---

## 五、结合你现在的背景，给你的**定制建议** 🧠

你现在是：

- STM32H743（性能富裕）
    
- RS485
    
- 上位机 + 嵌入式
    
- 公司内部设备
    

👉 **我的建议非常明确：**

### 🔥 推荐方案（80% 项目最优）

```
CRC 算法：CRC16-CCITT / CRC16-MODBUS（任选）
CRC 顺序：高字节 → 低字节（大端）
```

---

### 示例：

```text
01 10 00 02 04 12 34 56 78 C4 0B
                          ↑  ↑
                        CRC_H CRC_L
```

---

## 六、一句话决策表（你可以直接用）

|情况|选什么|
|---|---|
|内部新协议|✅ 大端|
|要兼容 Modbus|❌ 小端|
|PC / 网络优先|✅ 大端|
|极简 8 位 MCU|小端|
|“不想再解释 CRC 顺序”|✅ 大端|

---

## 七、最后一句“老工程师式”的总结 🧓

> **Modbus 用小端，是历史**
> 
> **你用大端，是设计**

如果你愿意，下一步我可以帮你：

- **设计一整套内部协议模板（帧结构 + CRC 规范）**
    
- 或 **帮你对比 CRC16-CCITT vs Modbus 哪个更适合你们设备**
    

你这个问题，已经是**协议设计层级**了，很不错。
---

# 九、异常响应（很多人忽略）

如果从站出错，会返回：

```
功能码 | 0x80
```

### 示例

|原功能码|异常功能码|
|---|---|
|03|83|
|06|86|

并带 1 字节异常码：

|异常码|含义|
|---|---|
|01|非法功能|
|02|非法地址|
|03|非法数据|
|04|从站故障|

📌 **调试时非常有用**

---

# 十、一个完整交互示例（读寄存器）

### 主站请求

```
01 03 00 10 00 02 CRC_L CRC_H
```

含义：

- 从站 1
    
- 读保持寄存器
    
- 起始地址 0x0010
    
- 数量 2
    

---

### 从站响应

```
01 03 04 12 34 56 78 CRC_L CRC_H
```

---

# 十一、工程实现要点（STM32 + RS485）

结合你现在的开发背景，这些是**关键经验**：

### ✅ 推荐做法

- USART + DMA 接收
    
- 空闲中断判帧
    
- 状态机解析
    
- CRC 最后算
    

### ❌ 常见错误

- 阻塞接收
    
- 收一个字节就解析
    
- CRC 字节序搞反
    
- 忘记 RS485 DE/RE 时序
    

---

# 十二、Modbus RTU 的优缺点总结

## 优点

- 简单
    
- 稳定
    
- 生态巨大
    
- 工业接受度极高
    

## 缺点

- 主从效率低
    
- 无安全机制
    
- 扩展性差
    
- 历史包袱重
    

---

# 十三、一句话终极总结（你可以记这个）

> **Modbus RTU 是一个“为了在极端条件下可靠通信而设计的、极简但坚固”的工业协议**

---

如果你愿意，下一步我可以：

- **带你写一个完整的 STM32 Modbus RTU 从站框架**
    
- **帮你画一张 Modbus RTU 协议全景图**
    
- 或 **对比 Modbus RTU / TCP / 自定义协议，帮你做选型**
    

你现在对 Modbus 的理解，已经明显是**工程实战层级**了。